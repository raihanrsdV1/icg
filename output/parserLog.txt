Line 1: type_specifier : INT

int

Line 1: type_specifier : INT

int

Line 1: parameter_list : type_specifier ID

int n

Line 2: variable : ID

n

Line 2: factor : variable

n

Line 2: unary_expression : factor

n

Line 2: term : unary_expression

n

Line 2: simple_expression : term

n

Line 2: factor : CONST_INT

0

Line 2: unary_expression : factor

0

Line 2: term : unary_expression

0

Line 2: simple_expression : term

0

Line 2: rel_expression : simple_expression RELOP simple_expression

n==0

Line 2: logic_expression : rel_expression

n==0

Line 2: expression : logic_expression

n==0

Line 3: factor : CONST_INT

1

Line 3: unary_expression : factor

1

Line 3: term : unary_expression

1

Line 3: simple_expression : term

1

Line 3: rel_expression : simple_expression

1

Line 3: logic_expression : rel_expression

1

Line 3: expression : logic_expression

1

Line 3: statement : RETURN expression SEMICOLON

return 1;

Line 3: statements : statement

return 1;

Line 4: compound_statement : LCURL statements RCURL

{
return 1;
}

ScopeTable # 1.1.1
ScopeTable # 1.1
5 --> < n : ID >
ScopeTable # 1
4 --> < fact : ID >

Line 4: statement : compound_statement

{
return 1;
}

Line 2: statement : IF LPAREN expression RPAREN statement

if(n==0){
return 1;
}

Line 4: statements : statement

if(n==0){
return 1;
}

Line 5: variable : ID

n

Line 5: factor : variable

n

Line 5: unary_expression : factor

n

Line 5: term : unary_expression

n

Line 5: simple_expression : term

n

Line 5: factor : CONST_INT

1

Line 5: unary_expression : factor

1

Line 5: term : unary_expression

1

Line 5: simple_expression : simple_expression ADDOP term

n-1

Line 5: rel_expression : simple_expression

n-1

Line 5: logic_expression : rel_expression

n-1

Line 5: arguments : logic_expression

n-1

Line 5: argument_list : arguments

n-1

Line 5: factor : ID LPAREN argument_list RPAREN

Error at line 5: Total number of arguments mismatch with declaration in function fact

fact(n-1)

Line 5: unary_expression : factor

fact(n-1)

Line 5: term : unary_expression

fact(n-1)

Line 5: variable : ID

n

Line 5: factor : variable

n

Line 5: unary_expression : factor

n

Line 5: term : term MULOP unary_expression

fact(n-1)*n

Line 5: simple_expression : term

fact(n-1)*n

Line 5: rel_expression : simple_expression

fact(n-1)*n

Line 5: logic_expression : rel_expression

fact(n-1)*n

Line 5: expression : logic_expression

fact(n-1)*n

Line 5: statement : RETURN expression SEMICOLON

return fact(n-1)*n;

Line 5: statements : statements statement

if(n==0){
return 1;
}
return fact(n-1)*n;

Line 6: compound_statement : LCURL statements RCURL

{
if(n==0){
return 1;
}
return fact(n-1)*n;
}

ScopeTable # 1.1
5 --> < n : ID >
ScopeTable # 1
4 --> < fact : ID >

Line 6: func_definition : type_specifier ID LPAREN parameter_list RPAREN compound_statement

int fact(int n){
if(n==0){
return 1;
}
return fact(n-1)*n;
}

Line 6: unit : func_definition

int fact(int n){
if(n==0){
return 1;
}
return fact(n-1)*n;
}

Line 6: program : unit

int fact(int n){
if(n==0){
return 1;
}
return fact(n-1)*n;
}

Line 8: type_specifier : INT

int

Line 8: declaration_list : ID

x

Line 8: var_declaration : type_specifier declaration_list SEMICOLON

int x;

Line 8: unit : var_declaration

int x;

Line 8: program : program unit

int fact(int n){
if(n==0){
return 1;
}
return fact(n-1)*n;
}
int x;

Line 9: type_specifier : VOID

void

Line 9: func_declaration : type_specifier ID LPAREN RPAREN SEMICOLON

void h();

Line 9: unit : func_declaration

void h();

Line 9: program : program unit

int fact(int n){
if(n==0){
return 1;
}
return fact(n-1)*n;
}
int x;
void h();

Line 10: type_specifier : INT

int

Line 10: type_specifier : INT

int

Line 10: parameter_list : type_specifier ID

int a

Line 10: type_specifier : INT

int

Line 10: parameter_list : parameter_list COMMA type_specifier ID

int a,int b

Line 10: func_declaration : type_specifier ID LPAREN parameter_list RPAREN SEMICOLON

int foo(int a,int b);

Line 10: unit : func_declaration

int foo(int a,int b);

Line 10: program : program unit

int fact(int n){
if(n==0){
return 1;
}
return fact(n-1)*n;
}
int x;
void h();
int foo(int a,int b);

Line 12: type_specifier : INT

int

Line 12: type_specifier : INT

int

Line 12: parameter_list : type_specifier ID

int a

Line 12: type_specifier : INT

int

Line 12: parameter_list : parameter_list COMMA type_specifier ID

int a,int b

Line 13: variable : ID

a

Line 13: factor : variable

a

Line 13: unary_expression : factor

a

Line 13: term : unary_expression

a

Line 13: simple_expression : term

a

Line 13: variable : ID

b

Line 13: factor : variable

b

Line 13: unary_expression : factor

b

Line 13: term : unary_expression

b

Line 13: simple_expression : simple_expression ADDOP term

a+b

Line 13: factor : CONST_INT

5

Line 13: unary_expression : factor

5

Line 13: term : unary_expression

5

Line 13: simple_expression : term

5

Line 13: rel_expression : simple_expression RELOP simple_expression

a+b<=5

Line 13: logic_expression : rel_expression

a+b<=5

Line 13: expression : logic_expression

a+b<=5

Line 14: factor : CONST_INT

7

Line 14: unary_expression : factor

7

Line 14: term : unary_expression

7

Line 14: simple_expression : term

7

Line 14: rel_expression : simple_expression

7

Line 14: logic_expression : rel_expression

7

Line 14: expression : logic_expression

7

Line 14: statement : RETURN expression SEMICOLON

return 7;

Line 14: statements : statement

return 7;

Line 15: compound_statement : LCURL statements RCURL

{
return 7;
}

ScopeTable # 1.2.1
ScopeTable # 1.2
0 --> < b : ID >
6 --> < a : ID >
ScopeTable # 1
1 --> < x : ID >
4 --> < fact : ID >< foo : ID >
6 --> < h : ID >

Line 15: statement : compound_statement

{
return 7;
}

Line 13: statement : IF LPAREN expression RPAREN statement

if(a+b<=5){
return 7;
}

Line 15: statements : statement

if(a+b<=5){
return 7;
}

Line 16: variable : ID

a

Line 16: factor : variable

a

Line 16: unary_expression : factor

a

Line 16: term : unary_expression

a

Line 16: simple_expression : term

a

Line 16: factor : CONST_INT

2

Line 16: unary_expression : factor

2

Line 16: term : unary_expression

2

Line 16: simple_expression : simple_expression ADDOP term

a-2

Line 16: rel_expression : simple_expression

a-2

Line 16: logic_expression : rel_expression

a-2

Line 16: arguments : logic_expression

a-2

Line 16: variable : ID

b

Line 16: factor : variable

b

Line 16: unary_expression : factor

b

Line 16: term : unary_expression

b

Line 16: simple_expression : term

b

Line 16: factor : CONST_INT

1

Line 16: unary_expression : factor

1

Line 16: term : unary_expression

1

Line 16: simple_expression : simple_expression ADDOP term

b-1

Line 16: rel_expression : simple_expression

b-1

Line 16: logic_expression : rel_expression

b-1

Line 16: arguments : arguments COMMA logic_expression

a-2,b-1

Line 16: argument_list : arguments

a-2,b-1

Line 16: factor : ID LPAREN argument_list RPAREN

Error at line 16: Type mismatch,  is an array

foo(a-2,b-1)

Line 16: unary_expression : factor

foo(a-2,b-1)

Line 16: term : unary_expression

foo(a-2,b-1)

Line 16: simple_expression : term

foo(a-2,b-1)

Line 16: factor : CONST_INT

2

Line 16: unary_expression : factor

2

Line 16: term : unary_expression

2

Line 16: variable : ID

a

Line 16: factor : variable

a

Line 16: unary_expression : factor

a

Line 16: term : unary_expression

a

Line 16: simple_expression : term

a

Line 16: factor : CONST_INT

1

Line 16: unary_expression : factor

1

Line 16: term : unary_expression

1

Line 16: simple_expression : simple_expression ADDOP term

a-1

Line 16: rel_expression : simple_expression

a-1

Line 16: logic_expression : rel_expression

a-1

Line 16: arguments : logic_expression

a-1

Line 16: variable : ID

b

Line 16: factor : variable

b

Line 16: unary_expression : factor

b

Line 16: term : unary_expression

b

Line 16: simple_expression : term

b

Line 16: factor : CONST_INT

2

Line 16: unary_expression : factor

2

Line 16: term : unary_expression

2

Line 16: simple_expression : simple_expression ADDOP term

b-2

Line 16: rel_expression : simple_expression

b-2

Line 16: logic_expression : rel_expression

b-2

Line 16: arguments : arguments COMMA logic_expression

a-1,b-2

Line 16: argument_list : arguments

a-1,b-2

Line 16: factor : ID LPAREN argument_list RPAREN

Error at line 16: Type mismatch,  is an array

foo(a-1,b-2)

Line 16: unary_expression : factor

foo(a-1,b-2)

Line 16: term : term MULOP unary_expression

2*foo(a-1,b-2)

Line 16: simple_expression : simple_expression ADDOP term

foo(a-2,b-1)+2*foo(a-1,b-2)

Line 16: rel_expression : simple_expression

foo(a-2,b-1)+2*foo(a-1,b-2)

Line 16: logic_expression : rel_expression

foo(a-2,b-1)+2*foo(a-1,b-2)

Line 16: expression : logic_expression

foo(a-2,b-1)+2*foo(a-1,b-2)

Line 16: statement : RETURN expression SEMICOLON

return foo(a-2,b-1)+2*foo(a-1,b-2);

Line 16: statements : statements statement

if(a+b<=5){
return 7;
}
return foo(a-2,b-1)+2*foo(a-1,b-2);

Line 17: compound_statement : LCURL statements RCURL

{
if(a+b<=5){
return 7;
}
return foo(a-2,b-1)+2*foo(a-1,b-2);
}

ScopeTable # 1.2
0 --> < b : ID >
6 --> < a : ID >
ScopeTable # 1
1 --> < x : ID >
4 --> < fact : ID >< foo : ID >
6 --> < h : ID >

Line 17: func_definition : type_specifier ID LPAREN parameter_list RPAREN compound_statement

int foo(int a,int b){
if(a+b<=5){
return 7;
}
return foo(a-2,b-1)+2*foo(a-1,b-2);
}

Line 17: unit : func_definition

int foo(int a,int b){
if(a+b<=5){
return 7;
}
return foo(a-2,b-1)+2*foo(a-1,b-2);
}

Line 17: program : program unit

int fact(int n){
if(n==0){
return 1;
}
return fact(n-1)*n;
}
int x;
void h();
int foo(int a,int b);
int foo(int a,int b){
if(a+b<=5){
return 7;
}
return foo(a-2,b-1)+2*foo(a-1,b-2);
}

Line 19: type_specifier : INT

int

Line 19: declaration_list : ID LTHIRD CONST_INT RTHIRD

y[5]

Line 19: var_declaration : type_specifier declaration_list SEMICOLON

int y[5];

Line 19: unit : var_declaration

int y[5];

Line 19: program : program unit

int fact(int n){
if(n==0){
return 1;
}
return fact(n-1)*n;
}
int x;
void h();
int foo(int a,int b);
int foo(int a,int b){
if(a+b<=5){
return 7;
}
return foo(a-2,b-1)+2*foo(a-1,b-2);
}
int y[5];

Line 21: type_specifier : VOID

void

Line 22: type_specifier : INT

int

Line 22: declaration_list : ID

y

Line 22: var_declaration : type_specifier declaration_list SEMICOLON

int y;

Line 22: statement : var_declaration

int y;

Line 22: statements : statement

int y;

Line 23: variable : ID

y

Line 23: factor : CONST_INT

22

Line 23: unary_expression : factor

22

Line 23: term : unary_expression

22

Line 23: simple_expression : term

22

Line 23: rel_expression : simple_expression

22

Line 23: logic_expression : rel_expression

22

Line 23: expression : variable ASSIGNOP logic_expression

y=22

Line 23: expression_statement : expression SEMICOLON

y=22;

Line 23: statement : expression_statement

y=22;

Line 23: statements : statements statement

int y;
y=22;

Line 24: statement : PRINTLN LPAREN ID RPAREN SEMICOLON

println(y);

Line 24: statements : statements statement

int y;
y=22;
println(y);

Line 25: compound_statement : LCURL statements RCURL

{
int y;
y=22;
println(y);
}

ScopeTable # 1.3
2 --> < y : ID >
ScopeTable # 1
1 --> < x : ID >
2 --> < y : ID >
4 --> < fact : ID >< foo : ID >
6 --> < h : ID >

Line 25: func_definition : type_specifier ID LPAREN RPAREN compound_statement

void h(){
int y;
y=22;
println(y);
}

Line 25: unit : func_definition

void h(){
int y;
y=22;
println(y);
}

Line 25: program : program unit

int fact(int n){
if(n==0){
return 1;
}
return fact(n-1)*n;
}
int x;
void h();
int foo(int a,int b);
int foo(int a,int b){
if(a+b<=5){
return 7;
}
return foo(a-2,b-1)+2*foo(a-1,b-2);
}
int y[5];
void h(){
int y;
y=22;
println(y);
}

Line 27: type_specifier : VOID

void

Line 29: compound_statement : LCURL RCURL

{}

ScopeTable # 1.4
ScopeTable # 1
1 --> < x : ID >
2 --> < y : ID >
4 --> < fact : ID >< foo : ID >
5 --> < g : ID >
6 --> < h : ID >

Line 29: func_definition : type_specifier ID LPAREN RPAREN compound_statement

void g(){}

Line 29: unit : func_definition

void g(){}

Line 29: program : program unit

int fact(int n){
if(n==0){
return 1;
}
return fact(n-1)*n;
}
int x;
void h();
int foo(int a,int b);
int foo(int a,int b){
if(a+b<=5){
return 7;
}
return foo(a-2,b-1)+2*foo(a-1,b-2);
}
int y[5];
void h(){
int y;
y=22;
println(y);
}
void g(){}

Line 31: type_specifier : INT

int

Line 31: type_specifier : INT

int

Line 31: parameter_list : type_specifier ID

int a

Line 31: type_specifier : INT

int

Line 31: parameter_list : parameter_list COMMA type_specifier ID

int a,int b

Line 32: variable : ID

a

Line 32: factor : variable

a

Line 32: unary_expression : factor

a

Line 32: term : unary_expression

a

Line 32: variable : ID

b

Line 32: factor : variable

b

Line 32: unary_expression : factor

b

Line 32: term : term MULOP unary_expression

a%b

Line 32: simple_expression : term

a%b

Line 32: rel_expression : simple_expression

a%b

Line 32: logic_expression : rel_expression

a%b

Line 32: expression : logic_expression

a%b

Line 32: statement : RETURN expression SEMICOLON

return a%b;

Line 32: statements : statement

return a%b;

Line 33: compound_statement : LCURL statements RCURL

{
return a%b;
}

ScopeTable # 1.5
0 --> < b : ID >
6 --> < a : ID >
ScopeTable # 1
1 --> < x : ID >< gg : ID >
2 --> < y : ID >
4 --> < fact : ID >< foo : ID >
5 --> < g : ID >
6 --> < h : ID >

Line 33: func_definition : type_specifier ID LPAREN parameter_list RPAREN compound_statement

int gg(int a,int b){
return a%b;
}

Line 33: unit : func_definition

int gg(int a,int b){
return a%b;
}

Line 33: program : program unit

int fact(int n){
if(n==0){
return 1;
}
return fact(n-1)*n;
}
int x;
void h();
int foo(int a,int b);
int foo(int a,int b){
if(a+b<=5){
return 7;
}
return foo(a-2,b-1)+2*foo(a-1,b-2);
}
int y[5];
void h(){
int y;
y=22;
println(y);
}
void g(){}
int gg(int a,int b){
return a%b;
}

Line 34: type_specifier : INT

int

Line 34: declaration_list : ID

i

Line 34: var_declaration : type_specifier declaration_list SEMICOLON

int i;

Line 34: unit : var_declaration

int i;

Line 34: program : program unit

int fact(int n){
if(n==0){
return 1;
}
return fact(n-1)*n;
}
int x;
void h();
int foo(int a,int b);
int foo(int a,int b){
if(a+b<=5){
return 7;
}
return foo(a-2,b-1)+2*foo(a-1,b-2);
}
int y[5];
void h(){
int y;
y=22;
println(y);
}
void g(){}
int gg(int a,int b){
return a%b;
}
int i;

Line 35: type_specifier : VOID

void

Line 36: variable : ID

i

Line 36: factor : CONST_INT

0

Line 36: unary_expression : factor

0

Line 36: term : unary_expression

0

Line 36: simple_expression : term

0

Line 36: rel_expression : simple_expression

0

Line 36: logic_expression : rel_expression

0

Line 36: expression : variable ASSIGNOP logic_expression

i=0

Line 36: expression_statement : expression SEMICOLON

i=0;

Line 36: variable : ID

i

Line 36: factor : variable

i

Line 36: unary_expression : factor

i

Line 36: term : unary_expression

i

Line 36: simple_expression : term

i

Line 36: factor : CONST_INT

5

Line 36: unary_expression : factor

5

Line 36: term : unary_expression

5

Line 36: simple_expression : term

5

Line 36: rel_expression : simple_expression RELOP simple_expression

i<=5

Line 36: logic_expression : rel_expression

i<=5

Line 36: expression : logic_expression

i<=5

Line 36: expression_statement : expression SEMICOLON

i<=5;

Line 36: variable : ID

i

Line 36: factor : variable INCOP

i++

Line 36: unary_expression : factor

i++

Line 36: term : unary_expression

i++

Line 36: simple_expression : term

i++

Line 36: rel_expression : simple_expression

i++

Line 36: logic_expression : rel_expression

i++

Line 36: expression : logic_expression

i++

Line 37: variable : ID

i

Line 37: factor : variable

i

Line 37: unary_expression : factor

i

Line 37: term : unary_expression

i

Line 37: simple_expression : term

i

Line 37: rel_expression : simple_expression

i

Line 37: logic_expression : rel_expression

i

Line 37: expression : logic_expression

i

Line 37: variable : ID LTHIRD expression RTHIRD

y[i]   

Line 37: factor : CONST_INT

101

Line 37: unary_expression : factor

101

Line 37: term : unary_expression

101

Line 37: simple_expression : term

101

Line 37: variable : ID

i

Line 37: factor : variable

i

Line 37: unary_expression : factor

i

Line 37: term : unary_expression

i

Line 37: simple_expression : simple_expression ADDOP term

101+i

Line 37: rel_expression : simple_expression

101+i

Line 37: logic_expression : rel_expression

101+i

Line 37: expression : variable ASSIGNOP logic_expression

y[i]=101+i

cums

